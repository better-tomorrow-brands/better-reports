# Shopify Webhooks (Orders + Customers)

Real-time ingestion of Shopify orders and customers via webhooks, with UTM attribution, repeat customer detection, and multi-tenant routing.

## How It Works

1. Shopify sends a POST webhook to `/api/webhooks/shopify/orders` or `/api/webhooks/shopify/customers`
2. The `X-Shopify-Shop-Domain` header is used to look up the correct org via `getOrgIdByStoreDomain()`
3. The request body is verified using HMAC-SHA256 with the org's `webhook_secret` from encrypted settings
4. The payload is parsed and upserted into the database, scoped to the org

## Webhook Endpoints

| Endpoint | Topic | Description |
|---|---|---|
| `POST /api/webhooks/shopify/orders` | `orders/create`, `orders/updated` | Upserts order with UTM attribution |
| `POST /api/webhooks/shopify/customers` | `customers/create`, `customers/update` | Upserts customer record |

Both endpoints are listed as public routes in `proxy.ts` (no Clerk auth required — they use HMAC verification instead).

## Multi-Tenant Routing

```
Incoming webhook
    │
    ├── Read X-Shopify-Shop-Domain header (e.g. "mystore.myshopify.com")
    │
    ▼
getOrgIdByStoreDomain(shopDomain)
    │
    ├── Query all settings rows where key = "shopify"
    ├── Decrypt each value (AES-256-GCM)
    ├── Compare store_domain to incoming domain
    └── Return matching orgId or null (→ 400 "Unknown shop domain")
```

This allows multiple Shopify stores to send webhooks to the same deployment, each routed to the correct organization.

## HMAC Verification

```
verifyShopifyHmac(body, hmacHeader, webhookSecret)
    │
    ├── Compute HMAC-SHA256 of raw body using webhook_secret
    ├── Base64-encode the result
    └── Compare to X-Shopify-Hmac-Sha256 header
```

The `webhook_secret` is stored per-org in the encrypted `settings` table under the `shopify` key.

## Order Webhook Flow

```
POST /api/webhooks/shopify/orders
        │
        ├── Multi-tenant routing (shop domain → orgId)
        ├── HMAC verification
        ├── Parse ShopifyOrderPayload
        │
        ▼
    upsertOrder(data, orgId)
        │
        ├── 1. UTM Attribution
        │   ├── Try: Shopify CustomerJourney API (GraphQL)
        │   │   └── order.customerJourneySummary.firstVisit.utmParameters
        │   │
        │   └── Fallback: campaigns_fcb lookup
        │       ├── 1st: Match by discount_code (case-insensitive)
        │       └── 2nd: Match by SKU (any SKU in order matches any SKU in campaign)
        │
        ├── 2. Repeat Customer Detection
        │   └── Check if email has prior orders with earlier createdAt
        │
        ├── 3. Build order record
        │   ├── Customer name (customer → shipping_address fallback)
        │   ├── Phone (customer → shipping → billing fallback)
        │   ├── Discount codes (comma-separated)
        │   ├── SKUs (comma-separated, falls back to item title)
        │   ├── Line item quantity (sum of all items)
        │   └── Tracking number (from fulfillments)
        │
        └── 4. Upsert
            ├── INSERT with full data (including UTM fields)
            └── ON CONFLICT (org_id, shopify_id) UPDATE
                └── Excludes utmSource, utmMedium, utmCampaign
                    to preserve manually-edited UTM fields
```

### UTM Attribution Priority

| Priority | Source | How |
|---|---|---|
| 1st | Shopify CustomerJourney API | GraphQL query for `order.customerJourneySummary.firstVisit.utmParameters` |
| 2nd | `campaigns_fcb` by discount code | Case-insensitive match on `discount_code` column |
| 3rd | `campaigns_fcb` by SKU | Any order SKU matches any campaign SKU (comma-separated lists) |

If no attribution is found from any source, UTM fields are left as empty strings.

### Preserving Manual Edits

On conflict (update), the upsert deliberately **excludes** `utmSource`, `utmMedium`, and `utmCampaign` from the update set. This means if a user manually edits UTM fields via the orders PATCH endpoint, subsequent webhook updates will not overwrite them.

The `utmContent` and `utmTerm` fields **are** updated on conflict since they are less commonly manually edited.

## Customer Webhook Flow

```
POST /api/webhooks/shopify/customers
        │
        ├── Multi-tenant routing (shop domain → orgId)
        ├── HMAC verification
        ├── Parse ShopifyCustomerPayload
        │
        └── Upsert by email (if exists) or shopifyCustomerId
            ├── Scoped to org (WHERE org_id = orgId AND email = ...)
            ├── If existing row found → UPDATE
            └── If no existing row → INSERT
```

Customer fields extracted from the webhook:

| Field | Source |
|---|---|
| `shopifyCustomerId` | `data.id` (converted to string) |
| `firstName` | `data.first_name` |
| `lastName` | `data.last_name` |
| `email` | `data.email` |
| `phone` | `data.phone` |
| `emailMarketingConsent` | `data.email_marketing_consent.state === "subscribed"` |
| `ordersCount` | `data.orders_count` |
| `totalSpent` | `data.total_spent` |
| `tags` | `data.tags` (comma-separated string) |
| `createdAt` | `data.created_at` |

## Manual Sync Endpoint

```
POST /api/orders/sync
```

Pulls the last 50 orders from Shopify via the Admin GraphQL API and upserts them using the same `upsertOrder()` function. Requires authentication via `requireOrgFromRequest()` (uses `X-Org-Id` header).

The GraphQL query fetches: `id`, `legacyResourceId`, `name`, `email`, `createdAt`, `displayFulfillmentStatus`, price sets, `tags`, `customer`, `shippingAddress`, `discountCodes`, `lineItems`, and `fulfillments`. Each GraphQL node is converted to a `ShopifyOrderPayload` before upserting.

The API also supports a `GET /api/orders` endpoint for listing orders (paginated, org-scoped) and `PATCH /api/orders` for manually editing UTM fields.

## Backfill Endpoints

| Endpoint | Method | Description |
|---|---|---|
| `/api/backfill/shopify` | `GET` | Backfill orders via GraphQL (paginated, requires `orgId` + `secret` query params) |
| `/api/backfill/shopify-customers` | `GET` | Backfill customers via GraphQL (paginated, requires `orgId` + `secret` query params) |

Both use `CRON_SECRET` or `dev-backfill` for authorization. Pagination is supported via `limit` and `cursor` query params.

**Orders backfill:**
```
GET /api/backfill/shopify?secret=dev-backfill&orgId=1&limit=50
```

**Customers backfill:**
```
GET /api/backfill/shopify-customers?secret=dev-backfill&orgId=1&limit=100
```

Both return `{ success, fetched, upserted, failed, hasNextPage, endCursor }`.

## Database Schema

### `orders` table

| Column | Type | Details |
|---|---|---|
| `id` | serial | Primary key |
| `org_id` | integer | FK → `organizations.id` (NOT NULL) |
| `shopify_id` | text | Shopify order ID (NOT NULL) |
| `order_number` | text | Human-readable order number |
| `email` | text | Customer email |
| `customer_name` | text | Derived from customer or shipping address |
| `phone` | text | From customer, shipping, or billing address |
| `created_at` | timestamptz | Order creation date |
| `fulfillment_status` | text | e.g. "unfulfilled", "fulfilled" |
| `fulfilled_at` | timestamptz | When order was fulfilled |
| `subtotal` | decimal(10,2) | Order subtotal |
| `shipping` | decimal(10,2) | Shipping cost |
| `tax` | decimal(10,2) | Tax amount |
| `total` | decimal(10,2) | Order total |
| `discount_codes` | text | Comma-separated discount codes |
| `skus` | text | Comma-separated SKUs (or item titles) |
| `quantity` | integer | Total line item quantity |
| `utm_source` | text | Attribution source |
| `utm_campaign` | text | Attribution campaign |
| `utm_medium` | text | Attribution medium |
| `utm_content` | text | Attribution content |
| `utm_term` | text | Attribution term |
| `tracking_number` | text | Fulfillment tracking numbers |
| `tags` | text | Shopify order tags |
| `has_conversion_data` | boolean | True if Shopify CustomerJourney returned UTM data |
| `is_repeat_customer` | boolean | True if email has earlier orders |
| `customer_id` | integer | FK → `customers.id` |
| `received_at` | timestamptz | When webhook was processed (default `now()`) |

**Unique index:** `(org_id, shopify_id)` — used for upsert conflict resolution.

### `customers` table

| Column | Type | Details |
|---|---|---|
| `id` | serial | Primary key |
| `org_id` | integer | FK → `organizations.id` (NOT NULL) |
| `shopify_customer_id` | text | Shopify customer ID |
| `first_name` | text | First name |
| `last_name` | text | Last name |
| `email` | text | Email address |
| `email_marketing_consent` | boolean | Subscribed to email marketing (default false) |
| `phone` | text | Phone number |
| `total_spent` | decimal(10,2) | Lifetime spend (default "0") |
| `orders_count` | integer | Total order count (default 0) |
| `tags` | text | Shopify customer tags |
| `created_at` | timestamptz | Customer creation date (default `now()`) |
| `last_order_at` | timestamptz | Date of most recent order |

**Unique index:** `(org_id, email)` — used for customer deduplication.

Computed fields (calculated on read, not stored):
- `lapse` — days since `last_order_at`
- `lifecycle` — New/Reorder/At Risk/Lost, computed from lapse using settings thresholds

## Key Files

| File | Purpose |
|---|---|
| `src/app/api/webhooks/shopify/orders/route.ts` | Order webhook endpoint (HMAC verify + upsert) |
| `src/app/api/webhooks/shopify/customers/route.ts` | Customer webhook endpoint (HMAC verify + upsert) |
| `src/lib/shopify-orders.ts` | `verifyShopifyHmac()`, `upsertOrder()`, `getCustomerJourney()`, `getAttributionFromCampaigns()` |
| `src/lib/settings.ts` | `getShopifySettings()`, `getOrgIdByStoreDomain()` |
| `src/lib/db/schema.ts` | Drizzle schema — `orders`, `customers` tables |
| `src/app/api/orders/route.ts` | List orders (GET) + manual UTM edit (PATCH) |
| `src/app/api/orders/sync/route.ts` | Manual sync — pulls last 50 orders via GraphQL |
| `src/app/api/customers/route.ts` | List customers (GET) with lapse + last WhatsApp date |
| `src/app/api/backfill/shopify/route.ts` | Historical order backfill (paginated GraphQL) |
| `src/app/api/backfill/shopify-customers/route.ts` | Historical customer backfill (paginated GraphQL) |

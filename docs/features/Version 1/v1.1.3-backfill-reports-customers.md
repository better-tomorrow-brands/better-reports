# Backfill Fixes, Reports Granularity, Customer Stats, Shopify Connection Options

Improvements to Shopify data backfill, customer metrics accuracy, reports granularity persistence, and Shopify connection setup.

---

## Shopify Connection: Custom App vs Partner Dashboard OAuth

### The 60-Day Order History Problem

Shopify's GraphQL API only returns orders from the last 60 days for Partner Dashboard apps unless the `read_all_orders` protected scope is explicitly approved by Shopify. This was confirmed by observing that the backfill consistently stopped at ~180 orders, with the oldest order falling exactly 60 days before the backfill date.

### Solution: Admin-Created Custom Apps

For admin-created custom apps (created directly in the client's Shopify Admin → Settings → Apps → Develop apps), the `read_all_orders` scope is automatically granted — no approval process required. Full order history is available immediately.

**Recommendation: use admin-created custom apps for all new client setups.**

### Settings UI Changes

The Shopify settings tab now shows two clearly labelled connection paths:

| | Option 1 — Custom App (Recommended) | Option 2 — Partner Dashboard OAuth |
|---|---|---|
| Setup | Client creates app in Shopify Admin | Developer creates app in Partner Dashboard |
| Order history | Full (no 60-day limit) | 60 days unless Shopify approves `read_all_orders` |
| Fields needed | Store Domain, Access Token, Webhook Secret | Client ID, Client Secret, then OAuth flow |

The OAuth flow and routes (`/api/auth/shopify` and `/api/auth/shopify/callback`) are preserved for existing Partner Dashboard setups and future use. Both methods store the resulting access token in the same `settings` table key; all downstream code (backfill, webhooks, reports) is unaffected.

**For new clients:**
1. Log into the client's Shopify Admin
2. Go to Settings → Apps and sales channels → Develop apps
3. Create an app, enable: `read_orders`, `write_orders`, `read_products`, `write_customers`, `read_analytics`
4. Install the app and copy the Admin API access token
5. Paste into Settings → Shopify → Admin API Access Token + Store Domain + Webhook Secret

---

## Shopify Backfill Fixes

### File: `src/app/api/backfill/shopify/route.ts`

**Status filter fix**

The Shopify GraphQL API does not accept `status:any`. Valid values are `open`, `closed`, `cancelled`, `not_closed`. The query was changed to an explicit OR:

```
status:open OR status:closed OR status:cancelled
```

**Empty startDate fix**

`URLSearchParams({ type, startDate })` would send `startDate=` even when the field was blank, causing the API to apply an empty date filter. The settings page now conditionally adds the param:

```typescript
const params = new URLSearchParams({ type });
if (startDate) params.set("startDate", startDate);
if (cursor) params.set("cursor", cursor);
```

**Debug logging**

Each backfill request now logs: `type`, `startDate`, `limit`, `cursor`, `orgId`, and (for orders) the full query filter string. The response logs `edges.length`, `hasNextPage`, and `endCursor` so pagination progress is visible in server logs.

---

## Customer Stats: DB Aggregate Endpoint

### Problem

The customer scorecards (Total Customers, Purchased, Prospects, etc.) were computed client-side from the loaded customer list, which was capped at 1,000 rows. Stores with more customers showed incorrect totals.

### Solution: `/api/customers/stats`

A dedicated endpoint runs all metrics in a single PostgreSQL query using `COUNT(*) FILTER (WHERE ...)` expressions:

```sql
SELECT
  count(*)                                                    AS total,
  count(*) filter (where orders_count > 0)                   AS purchased,
  count(*) filter (where email_marketing_consent = true)     AS email_subscribers,
  count(*) filter (where tags ilike '%active subscriber%')   AS active_subscribers,
  round(avg(total_spent) filter (where orders_count > 0), 2) AS avg_total_spent,
  round(avg(orders_count) filter (where orders_count > 0), 1) AS avg_orders_count,
  round(avg(extract(epoch from (now() - last_order_at)) / 86400)
        filter (where last_order_at is not null and orders_count > 0), 0) AS avg_lapse_days
FROM customers
WHERE org_id = $1
```

A second query computes the lifecycle breakdown (New / Due Reorder / Lapsed / Lost) using configurable day thresholds from `getLifecycleSettings(orgId)`.

### Non-Blocking Load

Stats fetch in parallel with the customer list and render as soon as they return — independent of list pagination. The scorecards show a skeleton while loading.

```typescript
// Both kick off simultaneously on org change
fetchStats();
fetchCustomers();
```

---

## Pagination: Orders and Customers Pages

Both pages now paginate at 100 rows per page. The underlying fetch still loads up to 9,999 rows; pagination is client-side over the filtered/sorted result set.

- Page resets to 1 whenever search, date range, filters, sort field, or sort direction changes
- Pagination controls only render when there are more than 100 rows
- Display format: `X–Y of Z` with Previous / Next buttons

---

## Reports Granularity Persistence

### Problem

Each chart component auto-suggests a `groupBy` (day/week/month) based on the selected date range. Switching tabs caused the chart to unmount and remount, re-running the auto-suggest and discarding the user's explicit choice.

### Solution: localStorage + useRef Guard

Each chart persists its `groupBy` selection to localStorage under a chart-specific key:

| Chart | localStorage key |
|---|---|
| Overall | `chart-overall-groupby` |
| Shopify | `chart-shopify-groupby` |
| Facebook Ads | `chart-facebook-ads-groupby` |
| Sessions | `chart-sessions-groupby` |
| Traffic | `chart-traffic-groupby` |
| Amazon | `chart-amazon-groupby` |

A `userSetGroupByRef = useRef(false)` tracks whether the user has explicitly chosen a groupBy in the current session (or whether one was restored from localStorage on mount).

```typescript
// On mount: restore persisted value
useEffect(() => {
  const stored = localStorage.getItem("chart-shopify-groupby");
  if (stored === "day" || stored === "week" || stored === "month") {
    setGroupBy(stored);
    userSetGroupByRef.current = true;
  }
}, []);

// On date range change: only auto-suggest if user hasn't chosen
if (dateRange !== prevDateRange) {
  setPrevDateRange(dateRange);
  if (!userSetGroupByRef.current) {
    setGroupBy(suggestGroupBy(dateRange));
  }
}

// On button click: persist and set flag
onClick={() => {
  setGroupBy(g);
  userSetGroupByRef.current = true;
  localStorage.setItem("chart-shopify-groupby", g);
}}
```

**Behaviour:**
- First visit: groupBy is auto-suggested from the date range as before
- After explicit selection: choice is remembered across tab switches and page reloads
- Date range changes no longer override an explicitly-chosen groupBy
